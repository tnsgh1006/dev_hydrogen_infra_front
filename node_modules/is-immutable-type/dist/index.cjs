'use strict';

var typeUtils = require('@typescript-eslint/type-utils');
var tsApiUtils = require('ts-api-utils');
var ts = require('typescript');
var path = require('node:path');

/**
 * The immutability values are sorted in ascending order.
 */
exports.Immutability = void 0;
(function (Immutability) {
    // eslint-disable-next-line @typescript-eslint/prefer-literal-enum-member
    Immutability[Immutability["Unknown"] = Number.NaN] = "Unknown";
    // MutableDeep = 1,
    Immutability[Immutability["Mutable"] = 2] = "Mutable";
    // MutableShallow = 2,
    // Readonly = 3,
    Immutability[Immutability["ReadonlyShallow"] = 3] = "ReadonlyShallow";
    Immutability[Immutability["ReadonlyDeep"] = 4] = "ReadonlyDeep";
    Immutability[Immutability["Immutable"] = 5] = "Immutable";
    // eslint-disable-next-line @typescript-eslint/prefer-literal-enum-member
    Immutability[Immutability["Calculating"] = Number.POSITIVE_INFINITY] = "Calculating";
})(exports.Immutability || (exports.Immutability = {}));

/**
 * Get the minimum immutability from the given values.
 *
 * Note: Unknown immutability will be ignore; thus Unknown will be return if
 * and only if all values are Unknown.
 */
function min(a, b) {
    if (isUnknown(a)) {
        return b;
    }
    if (isUnknown(b)) {
        return a;
    }
    return Math.min(a, b);
}
/**
 * Get the maximum immutability from the given values.
 *
 * Note: Unknown immutability will be ignore; thus Unknown will be return if
 * and only if all values are Unknown.
 */
function max(a, b) {
    if (isUnknown(a)) {
        return b;
    }
    if (isUnknown(b)) {
        return a;
    }
    return Math.max(a, b);
}
/**
 * Clamp the immutability between min and max.
 */
function clamp(minValue, value, maxValue) {
    return Math.max(minValue, Math.min(maxValue, value));
}
/**
 * Is the given immutability immutable?
 */
function isImmutable(immutability) {
    return immutability >= exports.Immutability.Immutable;
}
/**
 * Is the given immutability at least ReadonlyDeep?
 */
function isReadonlyDeep(immutability) {
    return immutability >= exports.Immutability.ReadonlyDeep;
}
/**
 * Is the given immutability at least ReadonlyShallow?
 */
function isReadonlyShallow(immutability) {
    return immutability >= exports.Immutability.ReadonlyShallow;
}
/**
 * Is the given immutability Mutable?
 */
function isMutable(immutability) {
    return immutability <= exports.Immutability.Mutable;
}
/**
 * Is the given immutability unknown?
 */
function isUnknown(value) {
    return Number.isNaN(value);
}

/* eslint-disable functional/no-conditional-statements */
/*
 * A class is used to store state and only calculate the data on demand.
 * This is more efficient than the functional approach.
 */
class TypeName {
    program;
    typeData;
    m_data;
    m_wrapperType;
    checker;
    constructor(program, typeData) {
        this.program = program;
        this.typeData = typeData;
        this.m_data = {};
        this.checker = program.getTypeChecker();
    }
    getName() {
        if (this.m_data.name === undefined) {
            if (tsApiUtils.isIntrinsicType(this.typeData.type)) {
                this.m_data.name = this.typeData.type.intrinsicName;
            }
            else {
                const symbol = this.typeData.type.getSymbol();
                if (symbol === undefined) {
                    const wrapperDeclarations = this.typeData.type.aliasSymbol?.declarations;
                    const wrapperDeclaration = wrapperDeclarations?.length === 1
                        ? wrapperDeclarations[0]
                        : undefined;
                    this.m_wrapperType =
                        wrapperDeclaration !== undefined &&
                            ts.isTypeAliasDeclaration(wrapperDeclaration) &&
                            ts.isTypeReferenceNode(wrapperDeclaration.type)
                            ? wrapperDeclaration.type
                            : undefined;
                    this.m_data.name =
                        this.m_wrapperType === undefined
                            ? null
                            : entityNameToString(this.m_wrapperType.typeName);
                }
                else if (tsApiUtils.isSymbolFlagSet(symbol, ts.SymbolFlags.TypeLiteral)) {
                    this.m_data.name = null;
                }
                else {
                    this.m_data.name = this.checker.symbolToString(symbol);
                }
            }
        }
        return this.m_data.name;
    }
    getNameWithArguments() {
        if (this.m_data.nameWithArguments === undefined) {
            if (this.m_data.name === undefined) {
                this.m_data.name = this.getName();
            }
            if (this.m_data.name === null || tsApiUtils.isIntrinsicType(this.typeData.type)) {
                this.m_data.nameWithArguments = null;
            }
            else {
                const symbol = this.typeData.type.getSymbol();
                if (symbol === undefined) {
                    if (this.m_wrapperType?.typeArguments === undefined) {
                        this.m_data.nameWithArguments = null;
                    }
                    else {
                        const wrapperArguments = typeArgumentsToString(this.program, getTypeData(this.checker.getTypeFromTypeNode(this.m_wrapperType), this.m_wrapperType), this.m_data.name, this.m_wrapperType.typeArguments.map((node) => this.checker.getTypeFromTypeNode(node)));
                        this.m_data.nameWithArguments =
                            wrapperArguments === undefined
                                ? null
                                : `${this.m_data.name}<${wrapperArguments}>`;
                    }
                }
                else {
                    const typeArguments = tsApiUtils.isTypeReference(this.typeData.type)
                        ? this.checker.getTypeArguments(this.typeData.type)
                        : undefined;
                    this.m_data.nameWithArguments =
                        typeArguments !== undefined && typeArguments.length > 0
                            ? `${this.m_data.name}<${typeArgumentsToString(this.program, this.typeData, this.m_data.name, typeArguments)}>`
                            : null;
                }
            }
        }
        return this.m_data.nameWithArguments;
    }
    getAlias() {
        if (this.m_data.alias === undefined) {
            this.m_data.alias = this.typeData.type.aliasSymbol?.escapedName ?? null;
        }
        return this.m_data.alias;
    }
    getAliasWithArguments() {
        if (this.m_data.aliasWithArguments === undefined) {
            if (this.typeData.type.aliasSymbol === undefined) {
                this.m_data.aliasWithArguments = null;
            }
            else {
                if (this.m_data.alias === undefined) {
                    this.m_data.alias = this.getAlias();
                }
                if (this.m_data.alias === null) {
                    this.m_data.aliasWithArguments = null;
                }
                else {
                    const aliasType = this.checker.getDeclaredTypeOfSymbol(this.typeData.type.aliasSymbol);
                    if (aliasType.aliasTypeArguments === undefined) {
                        this.m_data.aliasWithArguments = null;
                    }
                    else {
                        const aliasDeclarations = this.typeData.type.aliasSymbol.getDeclarations();
                        const aliasDeclaration = (aliasDeclarations?.length ?? 0) === 1
                            ? aliasDeclarations[0]
                            : undefined;
                        const aliasTypeNode = aliasDeclaration !== undefined && tsApiUtils.hasType(aliasDeclaration)
                            ? aliasDeclaration.type
                            : undefined;
                        const aliasArguments = typeArgumentsToString(this.program, getTypeData(aliasType, aliasTypeNode), this.m_data.alias, aliasType.aliasTypeArguments);
                        this.m_data.aliasWithArguments =
                            aliasArguments === undefined
                                ? null
                                : `${this.m_data.alias}<${aliasArguments}>`;
                    }
                }
            }
        }
        return this.m_data.aliasWithArguments;
    }
    getEvaluated() {
        if (this.m_data.evaluated === undefined) {
            if (this.typeData.typeNode !== null &&
                ts.isTypeReferenceNode(this.typeData.typeNode)) {
                const name = entityNameToString(this.typeData.typeNode.typeName);
                if (this.typeData.typeNode.typeArguments === undefined) {
                    this.m_data.evaluated = name;
                }
                else {
                    const typeArguments = typeArgumentsToString(this.program, this.typeData, undefined, this.typeData.typeNode.typeArguments);
                    this.m_data.evaluated =
                        typeArguments === undefined ? name : `${name}<${typeArguments}>`;
                }
            }
            else {
                this.m_data.evaluated = this.checker.typeToString(this.typeData.type);
            }
        }
        return this.m_data.evaluated;
    }
}
/**
 * Get string representations of the given type arguments.
 */
function typeArgumentsToString(program, typeData, name, typeArguments) {
    const typeArgumentStrings = typeArguments.map((typeLike) => {
        const typeArgument = isTypeNode(typeLike)
            ? getTypeData(program.getTypeChecker().getTypeFromTypeNode(typeLike), typeLike)
            : getTypeData(typeLike, undefined);
        if (typeData.type === typeArgument.type) {
            return name;
        }
        const typeName = typeToString(program, typeArgument);
        return (typeName.getNameWithArguments() ??
            typeName.getName() ??
            typeName.getEvaluated());
    });
    if (typeArgumentStrings.includes(undefined)) {
        console.warn("`typeArgumentStrings` contains `undefined`, this is likely a bug in `is-immutable-type`");
        return undefined;
    }
    return `${typeArgumentStrings.join(",")}`;
}
const cache = new WeakMap();
/**
 * Get string representations of the given type.
 */
function typeToString(program, typeData) {
    const cached = getCachedData(program, cache, typeData);
    if (cached !== undefined) {
        return cached;
    }
    const typeName = new TypeName(program, typeData);
    cacheData(program, cache, typeData, typeName);
    return typeName;
}

/**
 * Type guard to check if a Node has a Symbol.
 */
function hasSymbol(node) {
    return Object.hasOwn(node, "symbol");
}
/**
 * Type guard to check if a Type is TypeNode.
 */
function isTypeNode(typeLike) {
    return Object.hasOwn(typeLike, "kind");
}
/**
 * Check if a type node is anonymous;
 */
function isAnonymousTypeNode(typeNode) {
    return typeNode.pos < 0;
}
/**
 * Get the type data from the given type or type node.
 *
 * @throws if the type is an error type.
 */
function getTypeData(type, typeNode) {
    if (tsApiUtils.isIntrinsicErrorType(type)) {
        throw new Error("ErrorType encountered.");
    }
    return {
        type,
        typeNode: typeNode === undefined ||
            typeNode === null ||
            isAnonymousTypeNode(typeNode)
            ? null
            : typeNode,
    };
}
/**
 * Cache a value by its type
 */
function cacheData(program, cache, typeData, value) {
    const checker = program.getTypeChecker();
    const identity = checker.getRecursionIdentity(typeData.type);
    // eslint-disable-next-line functional/no-conditional-statements
    if (typeData.typeNode !== null) {
        cache.set(typeData.typeNode, value);
    }
    cache.set(identity, value);
}
/**
 * Get a value by its cashed type.
 */
function getCachedData(program, cache, typeData) {
    const checker = program.getTypeChecker();
    const identity = typeData.typeNode ?? checker.getRecursionIdentity(typeData.type);
    return cache.get(identity);
}
/**
 * Does the given type/typeNode match the given specifier.
 */
function typeMatchesSpecifier(typeData, specifier, program) {
    if (tsApiUtils.isIntrinsicErrorType(typeData.type)) {
        return false;
    }
    const typeName = typeToString(program, typeData);
    if (typeof specifier === "string" || specifier instanceof RegExp) {
        return typeNameMatchesSpecifier(typeName, specifier);
    }
    if (!typeNameMatchesSpecifier(typeName, specifier)) {
        return false;
    }
    const declarationFiles = typeData.type
        .getSymbol()
        ?.getDeclarations()
        ?.map((declaration) => declaration.getSourceFile()) ?? [];
    switch (specifier.from) {
        case "file": {
            return isTypeDeclaredFromLocal(specifier.path, declarationFiles, program);
        }
        case "lib": {
            return isTypeDeclaredFromLib(declarationFiles, program);
        }
        case "package": {
            return isTypeDeclaredInPackage(specifier.package, declarationFiles, program);
        }
    }
}
/**
 * Test if the given type name matches the given specifier.
 */
function typeNameMatchesSpecifier(typeName, specifier) {
    const names = typeof specifier === "string"
        ? [specifier]
        : specifier instanceof RegExp || specifier.name === undefined
            ? []
            : Array.isArray(specifier.name)
                ? specifier.name
                : [specifier.name];
    const patterns = typeof specifier === "string"
        ? []
        : specifier instanceof RegExp
            ? [specifier]
            : specifier.pattern === undefined
                ? []
                : Array.isArray(specifier.pattern)
                    ? specifier.pattern
                    : [specifier.pattern];
    const name = typeName.getName();
    if (name !== null) {
        if (names.includes(name)) {
            return true;
        }
        const nameWithArguments = typeName.getNameWithArguments();
        if (patterns.some((pattern) => pattern.test(nameWithArguments ?? name))) {
            return true;
        }
    }
    const alias = typeName.getAlias();
    if (alias !== null) {
        if (names.includes(alias)) {
            return true;
        }
        if (patterns.some((pattern) => pattern.test(alias))) {
            return true;
        }
    }
    const aliasWithArguments = typeName.getAliasWithArguments();
    if (aliasWithArguments !== null &&
        patterns.some((pattern) => pattern.test(aliasWithArguments))) {
        return true;
    }
    const evaluated = typeName.getEvaluated();
    return (names.includes(evaluated) ||
        patterns.some((pattern) => pattern.test(evaluated)));
}
/**
 * Test if the type is declared in a TypeScript lib.
 */
function isTypeDeclaredFromLib(declarationFiles, program) {
    // Intrinsic type (i.e. string, number, boolean, etc).
    if (declarationFiles.length === 0) {
        return true;
    }
    return declarationFiles.some((declaration) => program.isSourceFileDefaultLibrary(declaration));
}
/**
 * Test if the type is declared in a TypeScript package.
 */
function isTypeDeclaredInPackage(packageName, declarationFiles, program) {
    // Handle scoped packages - if the name starts with @, remove it and replace / with __
    const typesPackageName = packageName.replace(/^@([^/]+)\//u, "$1__");
    const matcher = new RegExp(`${packageName}|${typesPackageName}`, "u");
    return declarationFiles.some((declaration) => {
        const packageIdName = program.sourceFileToPackageName.get(declaration.path);
        return (packageIdName !== undefined &&
            matcher.test(packageIdName) &&
            program.isSourceFileFromExternalLibrary(declaration));
    });
}
/**
 * Test if the type is declared in a local file.
 */
function isTypeDeclaredFromLocal(relativePath, declarationFiles, program) {
    if (relativePath === undefined) {
        const cwd = program.getCurrentDirectory().toLowerCase();
        const typeRoots = ts.getEffectiveTypeRoots(program.getCompilerOptions(), program);
        return declarationFiles.some((declaration) => {
            if (program.isSourceFileFromExternalLibrary(declaration)) {
                return false;
            }
            const fileName = declaration.fileName.toLowerCase();
            if (!fileName.startsWith(cwd)) {
                return false;
            }
            return (typeRoots?.some((typeRoot) => fileName.startsWith(typeRoot)) !== true);
        });
    }
    const absolutePath = path
        .join(program.getCurrentDirectory(), relativePath)
        .toLowerCase();
    return declarationFiles.some((declaration) => declaration.fileName.toLowerCase() === absolutePath);
}
/**
 * Get string representations of the given property name.
 */
function propertyNameToString(propertyName) {
    return ts.isIdentifier(propertyName) || ts.isPrivateIdentifier(propertyName)
        ? identifierToString(propertyName)
        : propertyName.getText();
}
/**
 * Get string representations of the given entity name.
 */
function entityNameToString(entityName) {
    return ts.isIdentifier(entityName)
        ? identifierToString(entityName)
        : qualifiedNameToString(entityName);
}
/**
 * Get string representations of the given identifier.
 */
function identifierToString(identifier) {
    return identifier.escapedText;
}
/**
 * Get string representations of the given qualified name.
 */
function qualifiedNameToString(qualifiedName) {
    return `${entityNameToString(qualifiedName.left)}.${identifierToString(qualifiedName.right)}`;
}

/**
 * Get the default overrides that are applied.
 */
function getDefaultOverrides() {
    return [
        {
            type: { from: "lib", name: "Map" },
            to: exports.Immutability.Mutable,
        },
        {
            type: { from: "lib", name: "Set" },
            to: exports.Immutability.Mutable,
        },
        {
            type: { from: "lib", name: "Date" },
            to: exports.Immutability.Mutable,
        },
        {
            type: { from: "lib", name: "URL" },
            to: exports.Immutability.Mutable,
        },
        {
            type: { from: "lib", name: "URLSearchParams" },
            to: exports.Immutability.Mutable,
        },
    ];
}
/**
 * A global cache that can be used between consumers.
 */
const globalCache = new WeakMap();
/**
 * Get the immutability of the given type.
 *
 * If you only care about the immutability up to a certain point, a
 * `maxImmutability` can be specified to help improve performance.
 *
 * @param program - The TypeScript Program to use.
 * @param typeOrTypeNode - The type to test the immutability of.
 * @param overrides - The overrides to use when calculating the immutability.
 * @param useCache - Either a custom cache to use, `true` to use the global
 * cache, or `false` to not use any predefined cache.
 * @param maxImmutability - If set then any return value equal to or greater
 * than this value will state the type's minimum immutability rather than it's
 * actual. This allows for early-escapes to be made in the type calculation.
 */
function getTypeImmutability(program, typeOrTypeNode, overrides = getDefaultOverrides(), useCache = true, maxImmutability = exports.Immutability.Immutable) {
    const givenTypeNode = isTypeNode(typeOrTypeNode);
    const type = givenTypeNode
        ? program.getTypeChecker().getTypeFromTypeNode(typeOrTypeNode)
        : typeOrTypeNode;
    const typeNode = givenTypeNode ? typeOrTypeNode : undefined;
    const typeData = getTypeData(type, typeNode);
    return getTypeImmutabilityHelper(program, typeData, overrides, useCache, maxImmutability);
}
/**
 * Get the immutability of the given type data.
 */
function getTypeImmutabilityHelper(program, typeData, overrides, useCache, maxImmutability) {
    const cache = useCache === true
        ? globalCache
        : useCache === false
            ? new WeakMap()
            : useCache;
    const cached = getCachedData(program, cache, typeData);
    if (cached !== undefined) {
        return cached;
    }
    const override = getOverride(program, typeData, overrides);
    const overrideTo = override?.to;
    const overrideFrom = override?.from;
    // Early escape if we don't need to check the override from.
    if (overrideTo !== undefined && overrideFrom === undefined) {
        cacheData(program, cache, typeData, overrideTo);
        return overrideTo;
    }
    cacheData(program, cache, typeData, exports.Immutability.Calculating);
    const immutability = calculateTypeImmutability(program, typeData, overrides, cache, maxImmutability);
    if (overrideTo !== undefined) {
   
        if ((overrideFrom <= immutability && immutability <= overrideTo) ||
            (overrideFrom >= immutability && immutability >= overrideTo)) {
            cacheData(program, cache, typeData, overrideTo);
            return overrideTo;
        }
    }
    cacheData(program, cache, typeData, immutability);
    return immutability;
}
/**
 * Get the override for the type if it has one.
 */
function getOverride(program, typeData, overrides) {
    return overrides.find((potentialOverride) => typeMatchesSpecifier(typeData, potentialOverride.type, program));
}
/**
 * Calculated the immutability of the given type.
 */
function calculateTypeImmutability(program, typeData, overrides, cache, maxImmutability) {
    // Union?
    if (tsApiUtils.isUnionType(typeData.type)) {
        return typeData.type.types
            .map((type, index) => {
            const typeNode = typeData.typeNode !== null && ts.isUnionTypeNode(typeData.typeNode)
                ? typeData.typeNode.types[index]
                : undefined; // TODO: can we safely get a union type node nested within a different type node?
            return getTypeImmutabilityHelper(program, getTypeData(type, typeNode), overrides, cache, maxImmutability);
        })
            .reduce(min);
    }
    // Intersection?
    if (tsApiUtils.isIntersectionType(typeData.type)) {
        return objectImmutability(program, typeData, overrides, cache, maxImmutability);
    }
    // Conditional?
    if (tsApiUtils.isConditionalType(typeData.type)) {
        return [typeData.type.root.node.trueType, typeData.type.root.node.falseType]
            .map((typeNode) => {
            const checker = program.getTypeChecker();
            const type = checker.getTypeFromTypeNode(typeNode);
            return getTypeImmutabilityHelper(program, getTypeData(type, typeNode), overrides, cache, maxImmutability);
        })
            .reduce(min);
    }
    // (Non-namespace) Function?
    if (typeData.type.getCallSignatures().length > 0 &&
        typeData.type.getProperties().length === 0) {
        return exports.Immutability.Immutable;
    }
    const checker = program.getTypeChecker();
    // Tuple?
    if (checker.isTupleType(typeData.type)) {
        if (!typeData.type.target.readonly) {
            return exports.Immutability.Mutable;
        }
        return arrayImmutability(program, typeData, overrides, cache, maxImmutability);
    }
    // Array?
    if (checker.isArrayType(typeData.type)) {
        return arrayImmutability(program, typeData, overrides, cache, maxImmutability);
    }
    // Other type of object?
    if (tsApiUtils.isObjectType(typeData.type)) {
        return objectImmutability(program, typeData, overrides, cache, maxImmutability);
    }
    // Must be a primitive.
    return exports.Immutability.Immutable;
}
/**
 * Get the immutability of the given array.
 */
function arrayImmutability(program, typeData, overrides, cache, maxImmutability) {
    const shallowImmutability = objectImmutability(program, typeData, overrides, cache, maxImmutability);
    if (shallowImmutability <= exports.Immutability.ReadonlyShallow ||
        shallowImmutability >= maxImmutability) {
        return shallowImmutability;
    }
    const deepImmutability = typeArgumentsImmutability(program, typeData, overrides, cache, maxImmutability);
    return clamp(exports.Immutability.ReadonlyShallow, deepImmutability, shallowImmutability);
}
/**
 * Get the immutability of the given object.
 */
function objectImmutability(program, typeData, overrides, cache, maxImmutability) {
    const checker = program.getTypeChecker();
    let m_maxImmutability = maxImmutability;
    let m_minImmutability = exports.Immutability.Mutable;
    const properties = typeData.type.getProperties();
    // eslint-disable-next-line functional/no-conditional-statements
    if (properties.length > 0) {
        // eslint-disable-next-line functional/no-loop-statements
        for (const property of properties) {
            if (tsApiUtils.isPropertyReadonlyInType(typeData.type, property.getEscapedName(), checker) ||
                // Ignore "length" for tuples.
                // TODO: Report this issue to upstream.
                (property.escapedName === "length" &&
                    checker.isTupleType(typeData.type))) {
                continue;
            }
            const name = ts.getNameOfDeclaration(property.valueDeclaration);
            if (name !== undefined && ts.isPrivateIdentifier(name)) {
                continue;
            }
            const declarations = property.getDeclarations() ?? [];
            if (declarations.length > 0) {
                if (declarations.some((declaration) => hasSymbol(declaration) &&
                    tsApiUtils.isSymbolFlagSet(declaration.symbol, ts.SymbolFlags.Method))) {
                    m_maxImmutability = min(m_maxImmutability, exports.Immutability.ReadonlyDeep);
                    continue;
                }
                if (declarations.every((declaration) => ts.isPropertySignature(declaration) &&
                    declaration.type !== undefined &&
                    ts.isFunctionTypeNode(declaration.type))) {
                    m_maxImmutability = min(m_maxImmutability, exports.Immutability.ReadonlyDeep);
                    continue;
                }
            }
            return exports.Immutability.Mutable;
        }
        m_minImmutability = exports.Immutability.ReadonlyShallow;
        const propertyNodes = new Map(typeData.typeNode !== null &&
            tsApiUtils.hasType(typeData.typeNode) &&
            typeData.typeNode.type !== undefined &&
            ts.isTypeLiteralNode(typeData.typeNode.type)
            ? typeData.typeNode.type.members
                .map((member) => member.name === undefined ||
                !tsApiUtils.hasType(member) ||
                member.type === undefined
                ? undefined
                : [propertyNameToString(member.name), member.type])
                .filter((v) => v !== undefined)
            : []);
        // eslint-disable-next-line functional/no-loop-statements
        for (const property of properties) {
            const propertyType = typeUtils.getTypeOfPropertyOfType(checker, typeData.type, property);
            if (propertyType === undefined ||
                (tsApiUtils.isIntrinsicType(propertyType) &&
                    propertyType.intrinsicName === "error")) {
                continue;
            }
            const propertyTypeNode = propertyNodes.get(property.getEscapedName());
            const result = getTypeImmutabilityHelper(program, getTypeData(propertyType, propertyTypeNode), overrides, cache, maxImmutability);
            m_maxImmutability = min(m_maxImmutability, result);
            if (m_minImmutability >= m_maxImmutability) {
                return m_minImmutability;
            }
        }
    }
    if (tsApiUtils.isTypeReference(typeData.type)) {
        const result = typeArgumentsImmutability(program, typeData, overrides, cache, maxImmutability);
        m_maxImmutability = min(m_maxImmutability, result);
        if (m_minImmutability >= m_maxImmutability) {
            return m_minImmutability;
        }
    }
    const types = tsApiUtils.isIntersectionType(typeData.type)
        ? typeData.type.types
        : [typeData.type];
    const typeNodes = typeData.typeNode === null
        ? undefined
        : ts.isIntersectionTypeNode(typeData.typeNode)
            ? typeData.typeNode.types
            : [typeData.typeNode];
    const stringIndexSigImmutability = types
        .map((type, index) => indexSignatureImmutability(program, getTypeData(type, typeNodes?.[index]), ts.IndexKind.String, overrides, cache, maxImmutability))
        .reduce(max);
    m_maxImmutability = min(stringIndexSigImmutability, m_maxImmutability);
    if (m_minImmutability >= m_maxImmutability) {
        return m_minImmutability;
    }
    const numberIndexSigImmutability = types
        .map((type, index) => indexSignatureImmutability(program, getTypeData(type, typeNodes?.[index]), ts.IndexKind.Number, overrides, cache, maxImmutability))
        .reduce(max);
    m_maxImmutability = min(numberIndexSigImmutability, m_maxImmutability);
    if (m_minImmutability >= m_maxImmutability) {
        return m_minImmutability;
    }
    return max(m_minImmutability, m_maxImmutability);
}
/**
 * Get the immutability of the given type arguments.
 */
function typeArgumentsImmutability(program, typeData, overrides, cache, maxImmutability) {
    if (typeData.type.typeArguments !== undefined &&
        typeData.type.typeArguments.length > 0) {
        return typeData.type.typeArguments
            .map((type) => getTypeImmutabilityHelper(program, getTypeData(type, undefined), // TODO: can we get a type node for this?
        overrides, cache, maxImmutability))
            .reduce(min);
    }
    return exports.Immutability.Unknown;
}
/**
 * Get the immutability of the given index signature.
 */
function indexSignatureImmutability(program, typeData, kind, overrides, cache, maxImmutability) {
    const checker = program.getTypeChecker();
    const indexInfo = checker.getIndexInfoOfType(typeData.type, kind);
    if (indexInfo === undefined) {
        return exports.Immutability.Unknown;
    }
    if (maxImmutability <= exports.Immutability.ReadonlyShallow) {
        return exports.Immutability.ReadonlyShallow;
    }
    if (indexInfo.isReadonly) {
        if (indexInfo.type === typeData.type) {
            return maxImmutability;
        }
        return max(exports.Immutability.ReadonlyShallow, getTypeImmutabilityHelper(program, getTypeData(indexInfo.type, undefined), // TODO: can we get a type node for this?
        overrides, cache, maxImmutability));
    }
    return exports.Immutability.Mutable;
}

/**
 * Is the immutability of the given type immutable.
 *
 * @param program - The TypeScript Program to use.
 * @param typeOrTypeNode - The type to test the immutability of.
 * @param overrides - The overrides to use when calculating the immutability.
 * @param useCache - Either a custom cache to use, `true` to use the global
 * cache, or `false` to not use any predefined cache.
 */
function isImmutableType(program, typeOrTypeNode, overrides = getDefaultOverrides(), useCache = true) {
    const immutability = getTypeImmutability(program, typeOrTypeNode, overrides, useCache, exports.Immutability.Immutable);
    return isImmutable(immutability);
}
/**
 * Is the immutability of the given type at least readonly deep.
 *
 * @param program - The TypeScript Program to use.
 * @param typeOrTypeNode - The type to test the immutability of.
 * @param overrides - The overrides to use when calculating the immutability.
 * @param useCache - Either a custom cache to use, `true` to use the global
 * cache, or `false` to not use any predefined cache.
 */
function isReadonlyDeepType(program, typeOrTypeNode, overrides = getDefaultOverrides(), useCache = true) {
    const immutability = getTypeImmutability(program, typeOrTypeNode, overrides, useCache, exports.Immutability.ReadonlyDeep);
    return isReadonlyDeep(immutability);
}
/**
 * Is the immutability of the given type at least readonly shallow.
 *
 * @param program - The TypeScript Program to use.
 * @param typeOrTypeNode - The type to test the immutability of.
 * @param overrides - The overrides to use when calculating the immutability.
 * @param useCache - Either a custom cache to use, `true` to use the global
 * cache, or `false` to not use any predefined cache.
 */
function isReadonlyShallowType(program, typeOrTypeNode, overrides = getDefaultOverrides(), useCache = true) {
    const immutability = getTypeImmutability(program, typeOrTypeNode, overrides, useCache, exports.Immutability.ReadonlyShallow);
    return isReadonlyShallow(immutability);
}
/**
 * Is the immutability of the given type mutable.
 *
 * @param program - The TypeScript Program to use.
 * @param typeOrTypeNode - The type to test the immutability of.
 * @param overrides - The overrides to use when calculating the immutability.
 * @param useCache - Either a custom cache to use, `true` to use the global
 * cache, or `false` to not use any predefined cache.
 */
function isMutableType(program, typeOrTypeNode, overrides = getDefaultOverrides(), useCache = true) {
    const immutability = getTypeImmutability(program, typeOrTypeNode, overrides, useCache, exports.Immutability.Mutable);
    return isMutable(immutability);
}

exports.clamp = clamp;
exports.getDefaultOverrides = getDefaultOverrides;
exports.getTypeImmutability = getTypeImmutability;
exports.isImmutable = isImmutable;
exports.isImmutableType = isImmutableType;
exports.isMutable = isMutable;
exports.isMutableType = isMutableType;
exports.isReadonlyDeep = isReadonlyDeep;
exports.isReadonlyDeepType = isReadonlyDeepType;
exports.isReadonlyShallow = isReadonlyShallow;
exports.isReadonlyShallowType = isReadonlyShallowType;
exports.isUnknown = isUnknown;
exports.max = max;
exports.min = min;
